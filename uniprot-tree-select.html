<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="uniprot-styling.html">

<dom-module id="uniprot-tree-select">
  <template>
    <style include="uniprot-styling"></style>
    <style>
      :host {
        display: block;
      }
      li.branch > a::after {
        position: absolute;
        right:10px;
        width: 0;
        height: 0;
        border: inset 6px;
        content: '';
        border-right-width: 0;
        border-left-style: solid;
        border-color: transparent transparent transparent #000;
      }
      li.branch:hover > ul {
        display: block;
        opacity: 1;
      }
      ul li {
        position: relative;
      }
      li ul {
        display: none;
        opacity: 0;
        padding-left: 1em;
      }
      .active {
        font-weight: bold;
      }
    </style>
    <ul id="treerootlist"></ul>
  </template>

  <script>
    /**
     * `uniprot-tree-select`
     * Tree select menu component for UniProt. Uses recursion.
     *
     * @customElement
     * @polymer
     * @demo demo/uniprot-tree-select-demo.html
     */
    class UniProtTreeSelect extends Polymer.Element {

      static get is() {
        return 'uniprot-tree-select';
      }

      static get properties() {
        return {
          data: {
            type: Array
          },
          selection: {
            type: String,
            notify: true
          }
        }
      }

      constructor() {
        super();
      }

      connectedCallback() {
        super.connectedCallback();
        this._handleData();
      }

      _handleData() {
        let treeRootList = this.$.treerootlist;
        this._traverseTree(this.data, treeRootList);
      }

      _traverseTree(data, el) {
        for (let item of data) {
          let li = document.createElement('li');
          let anchor = document.createElement('a');
          anchor.id = item.id;
          anchor.textContent = item.label;
          li.appendChild(anchor);
          el.appendChild(li);
          if (item.members) {
            let ul = document.createElement('ul')
            li.className = 'branch';
            li.appendChild(ul);
            this._traverseTree(item.members, ul);
          } else {
            li.addEventListener('click', e => this._handleTap(e));
          }
        }
      }

      _highlightPathToTarget(t) {
        if(t.id === 'treerootlist') {
          return;
        } else if(t.tagName === 'LI') {
          t.querySelector('a').classList.add('active');
        }
        if(t.parentNode) {
          this._highlightPathToTarget(t.parentNode);
        }
      }

      _clearHighlightedPaths() {
        let elts = this.shadowRoot.querySelectorAll('.active');
        for(let elt of elts) {
          elt.classList.remove('active');
        }
      }

      _handleTap(e) {
        this._clearHighlightedPaths();
        this._highlightPathToTarget(e.target);
        this.selection = e.target.id;
      }

    }

    window.customElements.define(UniProtTreeSelect.is, UniProtTreeSelect);
  </script>
</dom-module>
